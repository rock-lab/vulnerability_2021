data {
  int<lower=0> N;   // Total data points
  int<lower=0> J;   // Total unique guides
  int pam[N];       // Vector with guide id numbers
  
  int prior;        // boolean to check if doing just prior model

  vector[N] x;      // vector with generations
  vector[N] y;      // vector with L2FC
  vector[J] s;      // vector with predicted strengths
  
  // Priors
  real p_A1_mean;
  real p_A2_mean;
  real p_A1_std;
  real p_A2_std;


  real p_alpha_l_mean;
  real p_alpha_l_std;  // plateau start
  real p_beta_l_mean;
  real p_beta_l_std;  // plateau rate
  real p_gamma_mean;
  real p_gamma_std;   // transition

  real kappa;
  real rho;

}

parameters {

  cholesky_factor_corr[3] L_Omega;
 
  vector<lower=0>[3] tau;      // prior scale
  vector[3] mu_beta;
  vector[3] beta[J];
  vector[J] beta_e;
  real<lower=0> sigma;
  real<lower=0> nu_y;
  
  real<lower=0.0, upper=1.0> M;
  real<lower=0> B;
  ordered[2] A;
  
  real<lower=0> nu_beta_e;
  real<lower=0> beta_e_sigma;

  
}


model {
  vector[N] mu_ii;
  vector[J] gmu;

  
  sigma ~ normal(1, 5);
  tau[1] ~ cauchy(0, 2);
  tau[2] ~ cauchy(0, 2);
  tau[3] ~ cauchy(2, 2);
  L_Omega ~ lkj_corr_cholesky(1);

 
  A[1] ~ normal(p_A1_mean, p_A1_std);
  A[2] ~ normal(p_A2_mean, p_A2_std);

  B ~ normal(10, 5);  // slope
  M ~ beta(rho*kappa, (1.0-rho)*kappa);  // mid-point
  beta_e_sigma ~ normal(0, 2);
  nu_beta_e ~ gamma(2, 0.1);

  // Beta_e mean following shape of Hill curve 
  gmu = A[2] + (A[1]-A[2]) ./ (1+exp(-B * (s-M)));

  
  beta_e ~ student_t(nu_beta_e, gmu, beta_e_sigma);


  mu_beta[1] ~ normal(p_alpha_l_mean, p_alpha_l_std); // Alpha_L
  mu_beta[2] ~ normal(p_beta_l_mean, p_beta_l_std);   // Beta_L
  mu_beta[3] ~ normal(p_gamma_mean, p_gamma_std);     // Gamma
  
  nu_beta_e ~ gamma(2, 0.1);

  for (j in 1:J)
  {
    beta[j] ~ multi_normal_cholesky(mu_beta, diag_pre_multiply(tau, L_Omega));
  }

  
  nu_y ~ gamma(2, 0.1);
  // only do likelihood portion of prior < 1
  if (prior < 1){

    for (i in 1:N) {
      //  Apply 2-line model portions depending if data is before/after gamma
      if (x[i] <= beta[pam[i], 3])
      {
        mu_ii[i] = beta[pam[i], 1] + beta[pam[i], 2]*x[i];
      }
      else
      {
        mu_ii[i] = (beta[pam[i], 1] + beta[pam[i], 2]*beta[pam[i], 3]) + beta_e[pam[i]]*(x[i]-beta[pam[i],3]);
      }
    }

      y ~ student_t(nu_y, mu_ii, sigma);
    }

    
}

generated quantities{
  real min_beta_e;
  matrix[3,3] Omega;
  matrix[3,3] Sigma;
  
  min_beta_e = min(beta_e);
  Omega = multiply_lower_tri_self_transpose(L_Omega);
  Sigma = quad_form_diag(Omega, tau);
}


