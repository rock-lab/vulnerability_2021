

# Vulnerability modeling - parallel

# Imports ----
library(stringr)

source("vulnerability_modeling_tools.R")
source("vulnerability_plotting_tools.R")

require("optparse")


# Options ----
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7 -mtune=corei7')

options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)



# Main ----
args = commandArgs(trailingOnly=TRUE)



# test if there is at least one argument: if not, return an error
option_list = list(
    # Data stuff:
    make_option("--data", type="character", default="",
              help="Input data"),
    make_option("--dir", type="character", default="./",
              help="Base data dir to assume when looking or data"),
    make_option("--strain", type="character", default="",
              help="The strain used for this data e.g. H37Rv"),
    make_option("--label", type="character", default="",
              help="Label to use aka strain_exp_date"),
    make_option("--genes", type="character", default="",
              help="CSV list of ORF IDs to analyze. Default is empty, which takes all ORF IDs from data file"),
    make_option("--skip", type="character", default="",
              help="CSV list of ORF IDs to skip. Default is empty, so none are skipped."),
    make_option("--output", type="character", default="./data",
              help="Output dir"),
    make_option("--prior", type="character", default="",
                help="Previous/Reference results to use as priors"),


    # Stan stuff:
    make_option("--stan", type="character", default="single_guide_cov_betalogistic.stan",
              help="Path to stan model code."),

    #System stuff:
    make_option("--cores", type="numeric", default=40,
              help="Number of cores to use")



);


# Parse options
opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser);

# Check if it has necessary arguments
has_necessary_stuff = opt$label !="" & opt$strain !=""
stopifnot(has_necessary_stuff)


# Assign / create variables from the arguments
desired_strain = opt$strain
label = paste(opt$label, sep="_")
stancode.filepath = opt$stan


if (file.exists(opt$data)){
    DATA_PATH = opt$data
} else {
   DATA_PATH = file.path(opt$dir, paste0("data_", label, ".txt"))
}



message("Reading data...")
XFULL = read.table(DATA_PATH, sep=",", stringsAsFactors = FALSE, header=T)
ii_bad_ess = is.na(XFULL$ESS)
XFULL$ESS[ii_bad_ess] = "N/A"

ii_good = !is.na(XFULL$Y)
data = XFULL[ii_good,]


if (file.exists(opt$prior)){
  prior_data = read.csv(prior_path, sep="\t", comment.char = "#")
} else {
  prior_data = NULL
}



if (opt$genes == ""){
    unique_genes = unique(data$ORF)
} else {
    message(sprintf("Notice: Running on genes %s", opt$genes))
    unique_genes = strsplit(opt$genes, ",")
}

if (opt$skip != ""){
    message(sprintf("Notice: Skipping genes %s", opt$skip))
    genes_to_skip = strsplit(opt$skip, ",")
    ii_skip = unique_genes %in% genes_to_skip
    unique_genes = unique_genes[!ii_skip]
}


message("Creating output directory...")
out_dir = file.path(opt$output, desired_strain, label)
dir.create(out_dir, showWarnings = FALSE, recursive=TRUE)


message("Creating model...")  
vb_model = stan_model(stancode.filepath, save_dso = TRUE)
  
message("Running Stan on all genes...")
if(opt$cores > 1){
    mclapply(unique_genes, run_model, mc.cores=opt$cores, data=data, strain=desired_strain, folder=label, results_path=out_dir, prior_data=prior_data)
} else {
    for(gene in unique_genes){
        run_model(gene, data=data, strain=desired_strain, folder=label, results_path=out_dir, prior_data=prior_data)
    }
}



